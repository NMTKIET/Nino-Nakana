import discord
from discord.ext import commands
import os
from discord import app_commands, ui
from dotenv import load_dotenv
import requests
import json
import sqlite3
import random
import asyncio
import string
from datetime import datetime, timezone
import logging
from tenacity import retry, stop_after_attempt, wait_fixed

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s:%(levelname)s:%(name)s: %(message)s')
logger = logging.getLogger('discord_bot')

# Load environment variables from .env file
load_dotenv()

# Define Intents
intents = discord.Intents.default()
intents.message_content = True
intents.members = True

# Database file name
DATABASE_FILE = 'bot_data.db'

# Specific channel ID for admin commands
ALLOWED_ADMIN_CHANNEL_ID = 1383013260902531074

# Owner user IDs
OWNER_IDS = [1026107907646967838]

# Environment Variables
DISCORD_BOT_TOKEN = os.getenv('DISCORD_BOT_TOKEN')
YEUMONEY_API_TOKEN = os.getenv('YEUMONEY_API_TOKEN')
TEST_GUILD_ID = os.getenv('TEST_GUILD_ID')

# Placeholder for web generator URL (replace with your actual URL)
WEB_GENERATOR_BASE_URL = 'https://nmtkiet.github.io/NinoNakano/?key='

# Dictionary to store active multi-line input sessions for /quickaddug
quick_add_ug_sessions = {}

# Database connection pool
class Database:
    def __init__(self, db_file):
        self.conn = sqlite3.connect(db_file, check_same_thread=False)
        self.conn.row_factory = sqlite3.Row

    def get_cursor(self):
        return self.conn.cursor()

    def commit(self):
        self.conn.commit()

    def close(self):
        self.conn.close()

db = Database(DATABASE_FILE)

# Function to generate a random alphanumeric code
def generate_random_code(length=20):
    characters = string.ascii_uppercase + string.digits
    return ''.join(random.choice(characters) for _ in range(length))

# Function to initialize the database and tables
def init_db():
    cursor = db.get_cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS main_link (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            url TEXT NOT NULL
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS redemption_codes (
            code TEXT PRIMARY KEY
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS user_balances (
            user_id INTEGER PRIMARY KEY,
            hcoin_balance INTEGER DEFAULT 0
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS ug_phones (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            data_json TEXT NOT NULL UNIQUE
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS hcoin_pastebin_links (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            pastebin_url TEXT NOT NULL UNIQUE
        )
    ''')
    db.commit()
    initial_count, final_count = deduplicate_ug_phones_data()
    if initial_count != final_count:
        logger.info(f"Deduplication completed for ug_phones. Initial: {initial_count}, Final: {final_count}. Removed {initial_count - final_count} duplicates.")
    else:
        logger.info("No duplicates found in ug_phones table during startup deduplication.")

# Function to get user hcoin balance
def get_user_hcoin(user_id: int) -> int:
    cursor = db.get_cursor()
    cursor.execute("SELECT hcoin_balance FROM user_balances WHERE user_id = ?", (user_id,))
    result = cursor.fetchone()
    return result[0] if result else 0

# Function to update user hcoin balance
def update_user_hcoin(user_id: int, amount: int):
    cursor = db.get_cursor()
    cursor.execute("INSERT OR REPLACE INTO user_balances (user_id, hcoin_balance) VALUES (?, COALESCE((SELECT hcoin_balance FROM user_balances WHERE user_id = ?), 0) + ?)", (user_id, user_id, amount))
    db.commit()

# Function to deduplicate ug_phones data
def deduplicate_ug_phones_data():
    cursor = db.get_cursor()
    cursor.execute("SELECT COUNT(*) FROM ug_phones")
    initial_count = cursor.fetchone()[0]
    cursor.execute('''
        CREATE TEMPORARY TABLE IF NOT EXISTS ug_phones_temp AS
        SELECT MIN(id) as id, data_json
        FROM ug_phones
        GROUP BY data_json;
    ''')
    cursor.execute('DELETE FROM ug_phones;')
    cursor.execute('INSERT INTO ug_phones SELECT id, data_json FROM ug_phones_temp;')
    cursor.execute('DROP TABLE IF EXISTS ug_phones_temp;')
    cursor.execute("SELECT COUNT(*) FROM ug_phones")
    final_count = cursor.fetchone()[0]
    db.commit()
    return initial_count, final_count

# Function to generate web link with random code
def create_web_generator_link(code: str):
    web_link = f"{WEB_GENERATOR_BASE_URL}{code}"
    logger.info(f"Generated web link for code {code}: {web_link}")
    return web_link

@retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
def create_short_link(long_url: str):
    if not YEUMONEY_API_TOKEN:
        logger.error("Error: YEUMONEY_API_TOKEN is not set in environment variables.")
        return None
    api_url = "https://yeumoney.com/QL_api.php"
    params = {
        "token": YEUMONEY_API_TOKEN,
        "url": long_url,
        "format": "json"
    }
    try:
        response = requests.get(api_url, params=params)
        response.raise_for_status()
        result = response.json()
        if result.get("status") == "success" and "shortenedUrl" in result:
            logger.info(f"Successfully created short link: {result['shortenedUrl']}")
            return result["shortenedUrl"]
        else:
            error_message = result.get("message", "Unknown API error.")
            logger.error(f"Error creating short link on Yeumoney.com. API response: {result}. Error: {error_message}")
            return None
    except requests.exceptions.RequestException as e:
        logger.error(f"Error connecting to Yeumoney.com API: {e}")
        return None
    except json.JSONDecodeError:
        logger.error(f"Error decoding JSON from Yeumoney.com API response: {response.text}")
        return None

class MyBot(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix='!', intents=intents)
        self.quick_add_ug_sessions = quick_add_ug_sessions

    async def setup_hook(self):
        if TEST_GUILD_ID:
            try:
                test_guild_id_int = int(TEST_GUILD_ID)
                test_guild = discord.Object(id=test_guild_id_int)
                self.tree.copy_global_to(guild=test_guild)
                await self.tree.sync(guild=test_guild)
                logger.info(f'Slash commands synced for TEST_GUILD_ID: {test_guild_id_int} (instant sync)! Old commands removed.')
            except ValueError:
                logger.error(f"ERROR: Invalid TEST_GUILD_ID '{TEST_GUILD_ID}' in .env. Falling back to global sync.")
                await self.tree.sync()
                logger.info('Slash commands synced globally (may take up to 1 hour to appear). Old commands removed.')
            except Exception as e:
                logger.error(f"ERROR syncing to specific guild {TEST_GUILD_ID}: {e}. Falling back to global sync.")
                await self.tree.sync()
                logger.info('Slash commands synced globally (may take up to 1 hour to appear). Old commands removed.')
        else:
            await self.tree.sync()
            logger.info('Slash commands synced globally (may take up to 1 hour to appear). Old commands removed.')

    async def on_ready(self):
        logger.info(f'Logged in as {self.user}!')
        logger.info(f'Bot ID: {self.user.id}')
        for owner_id in OWNER_IDS:
            try:
                owner = await self.fetch_user(owner_id)
                logger.info(f"Owner ID {owner_id} is valid (User: {owner.display_name}).")
            except discord.NotFound:
                logger.error(f"Owner ID {owner_id} is invalid or not found.")
        await self.loop.run_in_executor(None, init_db)
        logger.info("Database initialized or checked.")

    async def on_tree_error(self, interaction: discord.Interaction, error: app_commands.AppCommandError):
        if isinstance(error, app_commands.CommandInvokeError):
            logger.error(f"CommandInvokeError in command '{interaction.command.name}' by {interaction.user.display_name} (ID: {interaction.user.id}) in channel {interaction.channel} (ID: {interaction.channel_id}): {error.original}")
            try:
                await interaction.response.send_message(f"Đã xảy ra lỗi khi thực thi lệnh: `{error.original}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)
            except discord.InteractionResponded:
                await interaction.followup.send(f"Đã xảy ra lỗi khi thực thi lệnh: `{error.original}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)
        elif isinstance(error, app_commands.CheckFailure):
            logger.warning(f"CheckFailure for command '{interaction.command.name}' by {interaction.user.display_name} (ID: {interaction.user.id}) in channel {interaction.channel} (ID: {interaction.channel_id}): {error}")
            message = "Bạn không phải là chủ sở hữu bot!" if interaction.user.id not in OWNER_IDS else f"Lệnh này chỉ có thể được sử dụng trong kênh quản trị viên: <#{ALLOWED_ADMIN_CHANNEL_ID}>."
            try:
                await interaction.response.send_message(message, ephemeral=True)
            except discord.InteractionResponded:
                await interaction.followup.send(message, ephemeral=True)
        else:
            logger.critical(f"Unknown AppCommand Error in command '{interaction.command.name}' by {interaction.user.display_name} (ID: {interaction.user.id}) in channel {interaction.channel} (ID: {interaction.channel_id}): {error}")
            try:
                await interaction.response.send_message(f"Đã xảy ra lỗi không mong muốn: `{error}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)
            except discord.InteractionResponded:
                await interaction.followup.send(f"Đã xảy ra lỗi không mong muốn: `{error}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)

bot = MyBot()

# Custom check for Owner user IDs
def is_owner(interaction: discord.Interaction) -> bool:
    is_owner = interaction.user.id in OWNER_IDS
    if not is_owner:
        logger.warning(f"User {interaction.user.display_name} (ID: {interaction.user.id}) attempted to use an owner command but is not an owner.")
    return is_owner

# Modified check for admin channel (Owners bypass channel restriction)
def is_allowed_admin_channel(interaction: discord.Interaction) -> bool:
    if interaction.user.id in OWNER_IDS:
        return True
    if interaction.channel.id != ALLOWED_ADMIN_CHANNEL_ID:
        logger.warning(f"Command '{interaction.command.name}' attempted by {interaction.user.display_name} (ID: {interaction.user.id}) in unauthorized channel #{interaction.channel.name} (ID: {interaction.channel_id}).")
    return interaction.channel.id == ALLOWED_ADMIN_CHANNEL_ID

@bot.event
async def on_message(message: discord.Message):
    if message.author.id == bot.user.id:
        return
    user_id = message.author.id
    content = message.content.strip()
    if user_id in bot.quick_add_ug_sessions:
        lower_content = content.lower()
        if lower_content in ["done", "xong", "hoàn tất"]:
            collected_data = bot.quick_add_ug_sessions.pop(user_id)
            logger.info(f"User {message.author.display_name} (ID: {user_id}) ended /quickaddug session. Collected {len(collected_data)} items.")
            if not collected_data:
                embed = discord.Embed(
                    title="ℹ️ Phiên kết thúc!",
                    description="Bạn đã kết thúc phiên nhưng không có Local Storage nào được gửi.",
                    color=discord.Color.light_grey()
                )
                await message.channel.send(embed=embed)
            else:
                cursor = db.get_cursor()
                added_count = 0
                skipped_count = 0
                error_count = 0
                for data_item in collected_data:
                    try:
                        json.loads(data_item)
                        cursor.execute("INSERT OR IGNORE INTO ug_phones (data_json) VALUES (?)", (data_item,))
                        if cursor.rowcount > 0:
                            added_count += 1
                        else:
                            skipped_count += 1
                    except json.JSONDecodeError:
                        error_count += 1
                        logger.error(f"Invalid JSON in Local Storage data for user {user_id}: {data_item[:50]}...")
                    except sqlite3.Error as e:
                        error_count += 1
                        logger.error(f"SQLite Error adding Local Storage data for user {user_id}: {e}")
                    except Exception as e:
                        error_count += 1
                        logger.error(f"Unexpected error adding Local Storage data for user {user_id}: {e}")
                db.commit()
                description = f"**{added_count}** Local Storage đã được thêm thành công vào kho.\n"
                if skipped_count > 0:
                    description += f"**{skipped_count}** Local Storage bị bỏ qua (đã tồn tại).\n"
                if error_count > 0:
                    description += f"**{error_count}** Local Storage gặp lỗi khi thêm (dữ liệu không phải JSON hoặc lỗi khác). Vui lòng kiểm tra console bot."
                embed = discord.Embed(
                    title="✅ Phiên Thêm Nhanh Local Storage Hoàn Tất!",
                    description=description,
                    color=discord.Color.green()
                )
                embed.set_footer(text="Phiên đã kết thúc. Bạn có thể dùng /list localstorage để xem.")
                await message.channel.send(embed=embed)
        elif lower_content == "cancel":
            if user_id in bot.quick_add_ug_sessions:
                bot.quick_add_ug_sessions.pop(user_id)
                logger.info(f"User {message.author.display_name} (ID: {user_id}) cancelled /quickaddug session.")
                embed = discord.Embed(
                    title="❌ Phiên Thêm Nhanh Local Storage đã Hủy!",
                    description="Phiên nhập Local Storage của bạn đã bị hủy bỏ. Không có dữ liệu nào được lưu.",
                    color=discord.Color.red()
                )
                await message.channel.send(embed=embed)
        else:
            try:
                json.loads(content)
                bot.quick_add_ug_sessions[user_id].append(content)
                logger.debug(f"User {message.author.display_name} (ID: {user_id}) added valid JSON to /quickaddug session: {content[:50]}...")
                await message.add_reaction("✅")
            except json.JSONDecodeError:
                logger.warning(f"Invalid JSON from {message.author.display_name} (ID: {user_id}) in /quickaddug session.")
                await message.add_reaction("❌")
                await message.channel.send(embed=discord.Embed(
                    title="❌ Dữ liệu không hợp lệ!",
                    description="Vui lòng gửi dữ liệu Local Storage dạng JSON hợp lệ.",
                    color=discord.Color.red()
                ), ephemeral=True)
    await bot.process_commands(message)

@bot.tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CommandInvokeError):
        logger.error(f"CommandInvokeError in command '{interaction.command.name}' by {interaction.user.display_name} (ID: {interaction.user.id}) in channel {interaction.channel} (ID: {interaction.channel_id}): {error.original}")
        try:
            await interaction.response.send_message(f"Đã xảy ra lỗi khi thực thi lệnh: `{error.original}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)
        except discord.InteractionResponded:
            await interaction.followup.send(f"Đã xảy ra lỗi khi thực thi lệnh: `{error.original}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)
    elif isinstance(error, app_commands.CheckFailure):
        logger.warning(f"CheckFailure for command '{interaction.command.name}' by {interaction.user.display_name} (ID: {interaction.user.id}) in channel {interaction.channel} (ID: {interaction.channel_id}): {error}")
        message = "Bạn không phải là chủ sở hữu bot!" if interaction.user.id not in OWNER_IDS else f"Lệnh này chỉ có thể được sử dụng trong kênh quản trị viên: <#{ALLOWED_ADMIN_CHANNEL_ID}>."
        try:
            await interaction.response.send_message(message, ephemeral=True)
        except discord.InteractionResponded:
            await interaction.followup.send(message, ephemeral=True)
    else:
        logger.critical(f"Unknown AppCommand Error in command '{interaction.command.name}' by {interaction.user.display_name} (ID: {interaction.user.id}) in channel {interaction.channel} (ID: {interaction.channel_id}): {error}")
        try:
            await interaction.response.send_message(f"Đã xảy ra lỗi không mong muốn: `{error}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)
        except discord.InteractionResponded:
            await interaction.followup.send(f"Đã xảy ra lỗi không mong muốn: `{error}`. Vui lòng liên hệ quản trị viên.", ephemeral=True)

@bot.tree.command(name='getcredit', description='Get a new unique code via a web generator link.')
@app_commands.checks.cooldown(1, 60.0, key=lambda i: i.user.id)
async def get_credit(interaction: discord.Interaction):
    user_id = interaction.user.id
    await interaction.response.defer(ephemeral=True)
    generated_code = generate_random_code(20)
    logger.info(f"User {interaction.user.display_name} (ID: {user_id}) requested /getcredit. Generated code: {generated_code}")
    web_link = await bot.loop.run_in_executor(None, create_web_generator_link, generated_code)
    if not web_link:
        embed = discord.Embed(
            title="❌ Không thể tạo liên kết!",
            description='Không thể tạo liên kết web cho mã của bạn. Vui lòng thử lại sau hoặc liên hệ quản trị viên.',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        logger.error(f"Failed to create web link for user {user_id}'s /getcredit request.")
        return
    cursor = db.get_cursor()
    try:
        cursor.execute("INSERT INTO redemption_codes (code) VALUES (?)", (generated_code,))
        db.commit()
        logger.info(f"Code {generated_code} saved to DB for user {user_id}.")
    except sqlite3.IntegrityError:
        db.commit()
        embed = discord.Embed(
            title="❌ Lỗi tạo mã!",
            description='Không thể tạo mã duy nhất. Vui lòng thử lại.',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        logger.error(f"IntegrityError: Generated code {generated_code} already exists in DB for user {user_id}.")
        return
    short_link = await bot.loop.run_in_executor(None, create_short_link, web_link)
    if short_link:
        logger.info(f"User {user_id} used /getcredit. Short link: {short_link}")
        embed = discord.Embed(
            title="✨ Liên kết mã mới của bạn! ✨",
            description=f"Xin chào **{interaction.user.display_name}**! Đây là liên kết mã duy nhất mới của bạn. "
                        f"Sử dụng mã bên trong liên kết này với `/redeem` để nhận phần thưởng của bạn!",
            color=discord.Color.green()
        )
        embed.add_field(name="🔗 Lấy mã của bạn tại đây:", value=f"**<{short_link}>**", inline=False)
        embed.set_thumbnail(url=interaction.user.display_avatar.url)
        embed.timestamp = discord.utils.utcnow()
        await interaction.followup.send(embed=embed, ephemeral=True)
    else:
        cursor.execute("DELETE FROM redemption_codes WHERE code = ?", (generated_code,))
        db.commit()
        logger.error(f"Failed to create short link for web link {web_link}. Deleted code {generated_code} from DB.")
        embed = discord.Embed(
            title="❌ Không thể tạo liên kết!",
            description='Không thể tạo liên kết rút gọn vào lúc này. Mã đã tạo đã bị xóa. Vui lòng thử lại sau.',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)

@bot.tree.command(name='remove', description='Remove a specific redemption code from the list.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
@app_commands.describe(code='The code you want to remove (e.g., ABCDE12345)')
async def remove_code(interaction: discord.Interaction, code: str):
    cursor = db.get_cursor()
    cursor.execute("DELETE FROM redemption_codes WHERE code = ?", (code,))
    db.commit()
    if cursor.rowcount > 0:
        embed = discord.Embed(
            title="✅ Mã đã xóa thành công!",
            description=f'Mã `{code}` đã được xóa thành công.',
            color=discord.Color.green()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        logger.info(f"Code {code} removed by {interaction.user.display_name} (ID: {interaction.user.id}).")
    else:
        embed = discord.Embed(
            title="❌ Không tìm thấy mã!",
            description=f'Mã `{code}` không tồn tại trong danh sách.',
            color=discord.Color.red()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        logger.warning(f"Attempt to remove non-existent code {code} by {interaction.user.display_name} (ID: {interaction.user.id}).")

class RedeemMultipleCodesModal(ui.Modal, title='Đổi Nhiều Mã'):
    codes_input = ui.TextInput(
        label='Dán mã (mỗi mã một dòng)',
        placeholder='Nhập mỗi mã đổi thưởng trên một dòng mới...',
        style=discord.TextStyle.paragraph,
        max_length=4000
    )

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        user_id = interaction.user.id
        hcoin_per_code = 150
        raw_codes_input = self.codes_input.value
        codes_to_redeem = [code.strip() for code in raw_codes_input.split('\n') if code.strip()]
        logger.info(f"User {interaction.user.display_name} (ID: {user_id}) submitted {len(codes_to_redeem)} codes via quickredeemmodal.")
        if not codes_to_redeem:
            embed = discord.Embed(
                title="⚠️ Không có mã nào được cung cấp!",
                description="Vui lòng nhập ít nhất một mã để đổi.",
                color=discord.Color.orange()
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        cursor = db.get_cursor()
        redeemed_count = 0
        invalid_count = 0
        total_hcoin_earned = 0
        failed_codes = []
        for code in codes_to_redeem:
            try:
                cursor.execute("SELECT code FROM redemption_codes WHERE code = ?", (code,))
                existing_code = cursor.fetchone()
                if existing_code:
                    cursor.execute("DELETE FROM redemption_codes WHERE code = ?", (code,))
                    redeemed_count += 1
                    total_hcoin_earned += hcoin_per_code
                else:
                    invalid_count += 1
                    failed_codes.append(code)
            except sqlite3.Error as e:
                logger.error(f"SQLite Error processing code '{code}' for redemption by {user_id}: {e}")
                invalid_count += 1
                failed_codes.append(code)
            except Exception as e:
                logger.error(f"Unexpected error processing code '{code}' for redemption by {user_id}: {e}")
                invalid_count += 1
                failed_codes.append(code)
        db.commit()
        if total_hcoin_earned > 0:
            await bot.loop.run_in_executor(None, update_user_hcoin, user_id, total_hcoin_earned)
        current_balance = await bot.loop.run_in_executor(None, get_user_hcoin, user_id)
        title = "✨ Kết Quả Đổi Mã ✨"
        color = discord.Color.green() if redeemed_count > 0 else discord.Color.orange()
        description_parts = []
        if redeemed_count > 0:
            description_parts.append(f"✅ Đã đổi thành công **{redeemed_count}** mã.")
            description_parts.append(f"Bạn nhận được tổng cộng **{total_hcoin_earned} coin**.")
            logger.info(f"User {interaction.user.display_name} (ID: {user_id}) redeemed {redeemed_count} codes for {total_hcoin_earned} coins. New balance: {current_balance}.")
        if invalid_count > 0:
            description_parts.append(f"❌ **{invalid_count}** mã không hợp lệ hoặc đã được sử dụng.")
            if failed_codes:
                failed_codes_str = ", ".join(failed_codes[:10])
                if len(failed_codes) > 10:
                    failed_codes_str += f", ...và {len(failed_codes) - 10} mã khác"
                description_parts.append(f"Các mã không đổi được: `{failed_codes_str}`")
            logger.warning(f"User {interaction.user.display_name} (ID: {user_id}) had {invalid_count} invalid/used codes. Failed codes: {', '.join(failed_codes)}.")
        description_parts.append(f"\n**Số Coin Hiện Tại:** **{current_balance} coin**")
        embed = discord.Embed(
            title=title,
            description="\n".join(description_parts),
            color=color
        )
        embed.set_footer(text="Cảm ơn bạn đã sử dụng dịch vụ!")
        embed.timestamp = discord.utils.utcnow()
        await interaction.followup.send(embed=embed, ephemeral=False)

@bot.tree.command(name='redeem', description='Redeem a single code or show modal to redeem multiple codes.')
@app_commands.describe(code='The code you want to redeem (leave blank to show modal)')
async def redeem_code(interaction: discord.Interaction, code: str = None):
    if code:
        await interaction.response.defer(ephemeral=True)
        user_id = interaction.user.id
        hcoin_reward = 150
        cursor = db.get_cursor()
        try:
            cursor.execute("SELECT code FROM redemption_codes WHERE code = ?", (code,))
            existing_code = cursor.fetchone()
            if existing_code:
                cursor.execute("DELETE FROM redemption_codes WHERE code = ?", (code,))
                db.commit()
                await bot.loop.run_in_executor(None, update_user_hcoin, user_id, hcoin_reward)
                current_balance = await bot.loop.run_in_executor(None, get_user_hcoin, user_id)
                embed = discord.Embed(
                    title="✅ Đổi mã thành công!",
                    description=f'Bạn đã đổi mã `{code}` và nhận được **{hcoin_reward} coin**.',
                    color=discord.Color.green()
                )
                embed.add_field(name="Số dư hiện tại", value=f"**{current_balance} coin**", inline=True)
                await interaction.followup.send(embed=embed, ephemeral=False)
                logger.info(f"User {interaction.user.display_name} (ID: {user_id}) redeemed code {code} for {hcoin_reward} coins. New balance: {current_balance}.")
            else:
                embed = discord.Embed(
                    title="❌ Mã không hợp lệ!",
                    description=f'Mã `{code}` không tồn tại hoặc đã được sử dụng.',
                    color=discord.Color.red()
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                logger.warning(f"User {interaction.user.display_name} (ID: {user_id}) tried to redeem invalid/used code {code}.")
        except sqlite3.Error as e:
            logger.error(f"SQLite Error during /redeem for user {user_id}, code {code}: {e}")
            embed = discord.Embed(
                title="❌ Lỗi!",
                description='Đã xảy ra lỗi khi đổi mã của bạn. Vui lòng thử lại sau.',
                color=discord.Color.red()
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
        finally:
            db.commit()
    else:
        logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) used /redeem without a code, showing modal.")
        await interaction.response.send_modal(RedeemMultipleCodesModal())

@bot.tree.command(name='quickredeemcode', description='Redeem multiple codes directly at once.')
async def quick_redeem_code_command_modal(interaction: discord.Interaction):
    logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) used /quickredeemcode (modal).")
    await interaction.response.send_modal(RedeemMultipleCodesModal())

@bot.tree.command(name='list', description='Display a list of codes, Pastebin links, or Local Storage data.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
@app_commands.describe(type_to_list='Choose what to list: "code", "link", or "localstorage".')
@app_commands.choices(type_to_list=[
    app_commands.Choice(name="Codes", value="code"),
    app_commands.Choice(name="Pastebin Links", value="link"),
    app_commands.Choice(name="Local Storage", value="localstorage")
])
async def list_items(interaction: discord.Interaction, type_to_list: app_commands.Choice[str]):
    await interaction.response.defer(ephemeral=True)
    logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) used /list {type_to_list.value}.")
    cursor = db.get_cursor()
    title = ""
    color = discord.Color.blue()
    items = []
    if type_to_list.value == "code":
        title = "📜 Danh sách mã"
        cursor.execute("SELECT code FROM redemption_codes")
        items = cursor.fetchall()
        if not items:
            description = 'Không còn mã nào trong hệ thống.'
        else:
            response_lines = ["**Danh sách các mã còn lại (dùng cho /redeem):**"]
            for i, item_tuple in enumerate(items):
                response_lines.append(f"`{i+1}.` `{item_tuple[0]}`")
            description = "\n".join(response_lines)
    elif type_to_list.value == "link":
        title = "📜 Danh sách liên kết Pastebin"
        cursor.execute("SELECT pastebin_url FROM hcoin_pastebin_links")
        items = cursor.fetchall()
        if not items:
            description = 'Hiện tại không có liên kết Pastebin nào trong danh sách.'
        else:
            response_lines = ["**Danh sách các liên kết Pastebin chưa sử dụng:**"]
            for i, item_tuple in enumerate(items):
                response_lines.append(f"`{i+1}.` <{item_tuple[0]}>")
            description = "\n".join(response_lines)
    elif type_to_list.value == "localstorage":
        title = "📦 Kho Local Storage"
        cursor.execute("SELECT id, data_json FROM ug_phones")
        items = cursor.fetchall()
        if not items:
            description = 'Hiện tại không có Local Storage nào trong kho.'
            embed = discord.Embed(
                title=title,
                description=description,
                color=color
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            return
        formatted_items_lines = []
        for item_id, item_content in items:
            formatted_items_lines.append(f"**ID: `{item_id}`**\n```json\n{item_content}\n```")
        if len("\n".join(formatted_items_lines)) > 4000:
            await interaction.followup.send(embed=discord.Embed(
                title=title,
                description="Đang xử lý và gửi dữ liệu Local Storage. Điều này có thể cần nhiều tin nhắn.",
                color=discord.Color.blue()
            ), ephemeral=True)
            logger.info(f"Sending large Local Storage list to {interaction.user.display_name} (ID: {interaction.user.id}) in multiple messages.")
        current_embed_lines = []
        current_embed_length = 0
        max_embed_length = 3800
        for line in formatted_items_lines:
            line_length = len(line) + 1
            if current_embed_length + line_length > max_embed_length:
                embed_to_send = discord.Embed(
                    title=title,
                    description="\n".join(current_embed_lines),
                    color=color
                )
                await interaction.followup.send(embed=embed_to_send, ephemeral=True)
                current_embed_lines = []
                current_embed_length = 0
            current_embed_lines.append(line)
            current_embed_length += line_length
        if current_embed_lines:
            embed_to_send = discord.Embed(
                title=title,
                description="\n".join(current_embed_lines),
                color=color
            )
            embed_to_send.set_footer(text=f"Tổng số {type_to_list.name.lower()}: {len(items)}")
            await interaction.followup.send(embed=embed_to_send, ephemeral=True)
        return
    if len(description) > 4000:
        embed = discord.Embed(
            title=title,
            description="Danh sách quá dài để hiển thị hoàn toàn. Vui lòng kiểm tra cơ sở dữ liệu để xem toàn bộ danh sách.",
            color=color
        )
        embed.set_footer(text=f"Tổng số {type_to_list.name.lower()}: {len(items)}")
        await interaction.followup.send(embed=embed, ephemeral=True)
        logger.warning(f"List for {type_to_list.value} was too long for single embed, truncated for {interaction.user.display_name}.")
    else:
        embed = discord.Embed(
            title=title,
            description=description,
            color=color
        )
        embed.set_footer(text=f"Tổng số {type_to_list.name.lower()}: {len(items)}")
        await interaction.followup.send(embed=embed, ephemeral=True)

class UGPhoneModal(ui.Modal, title='Nhập Local Storage'):
    data_input = ui.TextInput(
        label='Dán mã hoặc File Json',
        placeholder='Nhập Local Storage tại đây...',
        style=discord.TextStyle.paragraph,
        max_length=4000
    )

    async def on_submit(self, interaction: discord.Interaction):
        cursor = db.get_cursor()
        try:
            json.loads(self.data_input.value)
            cursor.execute("INSERT OR IGNORE INTO ug_phones (data_json) VALUES (?)", (self.data_input.value,))
            if cursor.rowcount > 0:
                embed = discord.Embed(
                    title="✅ Đã lưu thành công!",
                    description='Dữ liệu Local Storage đã được lưu vào kho.',
                    color=discord.Color.green()
                )
                logger.info(f"Local Storage added via modal by {interaction.user.display_name} (ID: {interaction.user.id}).")
            else:
                embed = discord.Embed(
                    title="ℹ️ Dữ liệu đã tồn tại!",
                    description='Dữ liệu Local Storage này đã có trong kho. Không có gì được thêm vào.',
                    color=discord.Color.blue()
                )
                logger.info(f"Duplicate Local Storage attempted via modal by {interaction.user.display_name} (ID: {interaction.user.id}).")
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except json.JSONDecodeError:
            logger.error(f"Invalid JSON in Local Storage data via modal by {interaction.user.display_name} (ID: {interaction.user.id}).")
            embed = discord.Embed(
                title="❌ Dữ liệu không hợp lệ!",
                description="Vui lòng gửi dữ liệu Local Storage dạng JSON hợp lệ.",
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except sqlite3.Error as e:
            logger.error(f"SQLite Error when saving UG Phone data via modal for {interaction.user.display_name}: {e}")
            embed = discord.Embed(
                title="❌ Lỗi lưu trữ!",
                description=f'Đã xảy ra lỗi khi lưu dữ liệu Local Storage: {e}\n'
                            f'Vui lòng kiểm tra console bot để biết chi tiết hoặc liên hệ quản trị viên.',
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        except Exception as e:
            logger.critical(f"Unexpected error in UGPhoneModal.on_submit for {interaction.user.display_name}: {e}")
            embed = discord.Embed(
                title="❌ Lỗi không mong muốn!",
                description=f'Đã xảy ra lỗi không mong muốn: {e}',
                color=discord.Color.red()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
        finally:
            db.commit()

@bot.tree.command(name='addugphone', description='Add Local Storage info for users to receive.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
async def add_ug_phone(interaction: discord.Interaction):
    logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) used /addugphone (modal).")
    await interaction.response.send_modal(UGPhoneModal())

@bot.tree.command(name='quickaddug', description='Start a session to add multiple Local Storage entries.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
async def quick_add_ug_command(interaction: discord.Interaction):
    user_id = interaction.user.id
    if user_id in bot.quick_add_ug_sessions:
        embed = discord.Embed(
            title="⚠️ Phiên đã hoạt động!",
            description="Bạn đã có một phiên nhập Local Storage đang hoạt động. Vui lòng gửi `done` để kết thúc hoặc `cancel` để hủy bỏ phiên hiện tại.",
            color=discord.Color.orange()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        logger.warning(f"User {interaction.user.display_name} (ID: {user_id}) tried to start /quickaddug session but already has one.")
        return
    bot.quick_add_ug_sessions[user_id] = []
    embed = discord.Embed(
        title="✨ Đã bắt đầu phiên thêm nhanh Local Storage! ✨",
        description="Vui lòng bắt đầu dán các chuỗi Local Storage (mỗi chuỗi là một tin nhắn riêng biệt).\n"
                    "Khi bạn hoàn tất, hãy gửi tin nhắn `done` (hoặc `xong`, `hoàn tất`) để lưu trữ.\n"
                    "Gửi `cancel` để hủy bỏ phiên này.",
        color=discord.Color.blue()
    )
    await interaction.response.send_message(embed=embed, ephemeral=False)
    logger.info(f"User {interaction.user.display_name} (ID: {user_id}) started a /quickaddug session.")

@bot.tree.command(name='getugphone', description='Use 150 coins to receive Local Storage.')
async def get_ug_phone_command(interaction: discord.Interaction):
    user_id = interaction.user.id
    cost = 150
    is_owner_user = user_id in OWNER_IDS
    if not is_owner_user:
        current_balance = await bot.loop.run_in_executor(None, get_user_hcoin, user_id)
        if current_balance < cost:
            embed = discord.Embed(
                title="💰 Không đủ tiền!",
                description=f'Bạn không có đủ **{cost} coin** để nhận Local Storage. Số dư hiện tại của bạn là **{current_balance} coin**.',
                color=discord.Color.orange()
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            logger.warning(f"User {interaction.user.display_name} (ID: {user_id}) tried to /getugphone but had insufficient balance ({current_balance} < {cost}).")
            return
    await interaction.response.defer(ephemeral=True)
    cursor = db.get_cursor()
    cursor.execute("SELECT id, data_json FROM ug_phones ORDER BY RANDOM() LIMIT 1")
    result = cursor.fetchone()
    if not result:
        embed = discord.Embed(
            title="⚠️ Kho trống!",
            description='Hiện tại không có Local Storage nào trong kho. Vui lòng thử lại sau hoặc liên hệ quản trị viên.',
            color=discord.Color.orange()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        logger.warning(f"User {interaction.user.display_name} (ID: {user_id}) tried to /getugphone, but ug_phones table is empty.")
        return
    item_id, local_storage_data = result
    if not is_owner_user:
        await bot.loop.run_in_executor(None, update_user_hcoin, user_id, -cost)
        logger.info(f"User {interaction.user.display_name} (ID: {user_id}) used {cost} coins for Local Storage.")
    try:
        user_dm = await interaction.user.create_dm()
        dm_content = f"```\n{local_storage_data}\n```"
        chunk_size = 1990
        if len(dm_content) > chunk_size:
            chunks = [dm_content[i:i + chunk_size] for i in range(0, len(dm_content), chunk_size)]
            for i, chunk in enumerate(chunks):
                await user_dm.send(f"Phần {i+1}/{len(chunks)}:\n{chunk}")
            embed = discord.Embed(
                title="📦 Local Storage đã gửi!",
                description=f'Local Storage đã được gửi đến tin nhắn riêng của bạn (gồm {len(chunks)} phần). Vui lòng kiểm tra DM của bạn!',
                color=discord.Color.green()
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            logger.info(f"Sent Local Storage (in {len(chunks)} parts) to DM of {user_id}.")
        else:
            await user_dm.send(dm_content)
            embed = discord.Embed(
                title="📦 Local Storage đã gửi!",
                description=f'Local Storage đã được gửi đến tin nhắn riêng của bạn. Vui lòng kiểm tra DM của bạn!',
                color=discord.Color.green()
            )
            await interaction.followup.send(embed=embed, ephemeral=True)
            logger.info(f"Sent Local Storage to DM of {user_id}.")
        cursor.execute("DELETE FROM ug_phones WHERE id = ?", (item_id,))
        db.commit()
        logger.info(f"Local Storage item with ID {item_id} successfully deleted from DB after being sent to user {user_id}.")
    except discord.Forbidden:
        embed = discord.Embed(
            title="🚫 Không thể gửi DM!",
            description='Tôi không thể gửi tin nhắn trực tiếp cho bạn. Vui lòng bật **Cho phép tin nhắn trực tiếp từ thành viên máy chủ** trong cài đặt quyền riêng tư. Coin đã được hoàn lại.',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        logger.error(f"Failed to send DM to {user_id} for /getugphone (Forbidden). Local Storage ID {item_id} was NOT deleted.")
        if not is_owner_user:
            await bot.loop.run_in_executor(None, update_user_hcoin, user_id, cost)
            logger.info(f"Refunded {cost} coins to user {user_id} due to DM failure for Local Storage ID {item_id}.")
    except Exception as e:
        embed = discord.Embed(
            title="❌ Lỗi gửi DM!",
            description=f'Đã xảy ra lỗi khi gửi DM: {e}. Local Storage không bị trừ và vẫn còn trong kho.',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
        logger.critical(f"Unexpected error sending DM to {user_id} for /getugphone: {e}. Local Storage ID {item_id} was NOT deleted.")
        if not is_owner_user:
            await bot.loop.run_in_executor(None, update_user_hcoin, user_id, cost)
            logger.info(f"Refunded {cost} coins to user {user_id} due to DM failure for Local Storage ID {item_id}.")
    finally:
        db.commit()

@bot.tree.command(name='delete_ug_data', description='Delete a Local Storage entry by its full content.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
@app_commands.describe(data_to_delete='The exact Local Storage string to delete.')
async def delete_ug_data(interaction: discord.Interaction, data_to_delete: str):
    await interaction.response.defer(ephemeral=True)
    logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) used /delete_ug_data.")
    cursor = db.get_cursor()
    try:
        json.loads(data_to_delete)
        cursor.execute("DELETE FROM ug_phones WHERE data_json = ?", (data_to_delete,))
        db.commit()
        if cursor.rowcount > 0:
            embed = discord.Embed(
                title="✅ Xóa Local Storage Thành Công!",
                description="Dữ liệu Local Storage đã được xóa khỏi kho.",
                color=discord.Color.green()
            )
            logger.info(f"Local Storage deleted by {interaction.user.display_name} (ID: {interaction.user.id}).")
        else:
            embed = discord.Embed(
                title="❌ Không tìm thấy dữ liệu!",
                description="Không tìm thấy dữ liệu Local Storage khớp với nội dung bạn cung cấp.",
                color=discord.Color.red()
            )
            logger.warning(f"Local Storage not found for deletion by {interaction.user.display_name} (ID: {interaction.user.id}).")
        await interaction.followup.send(embed=embed, ephemeral=True)
    except json.JSONDecodeError:
        logger.error(f"Invalid JSON in Local Storage data for deletion by {interaction.user.display_name} (ID: {interaction.user.id}).")
        embed = discord.Embed(
            title="❌ Dữ liệu không hợp lệ!",
            description="Dữ liệu Local Storage phải là JSON hợp lệ.",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
    except sqlite3.Error as e:
        logger.error(f"SQLite Error deleting UG Phone data via /delete_ug_data for {interaction.user.display_name}: {e}")
        embed = discord.Embed(
            title="❌ Lỗi xóa!",
            description=f'Đã xảy ra lỗi khi xóa dữ liệu Local Storage: {e}\n'
                        f'Vui lòng kiểm tra console bot để biết chi tiết hoặc liên hệ quản trị viên.',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        logger.critical(f"Unexpected error in /delete_ug_data for {interaction.user.display_name}: {e}")
        embed = discord.Embed(
            title="❌ Lỗi không mong muốn!",
            description=f'Đã xảy ra lỗi không mong muốn: {e}',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)

@bot.tree.command(name='delete_ug_by_id', description='Delete a Local Storage entry by its unique ID.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
@app_commands.describe(item_id='The unique ID of the Local Storage entry to delete.')
async def delete_ug_by_id(interaction: discord.Interaction, item_id: int):
    await interaction.response.defer(ephemeral=True)
    logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) used /delete_ug_by_id with ID: {item_id}")
    cursor = db.get_cursor()
    try:
        cursor.execute("DELETE FROM ug_phones WHERE id = ?", (item_id,))
        db.commit()
        if cursor.rowcount > 0:
            embed = discord.Embed(
                title="✅ Xóa Local Storage Thành Công!",
                description=f"Dữ liệu Local Storage với ID `{item_id}` đã được xóa khỏi kho.",
                color=discord.Color.green()
            )
            logger.info(f"Local Storage with ID {item_id} deleted by {interaction.user.display_name} (ID: {interaction.user.id}).")
        else:
            embed = discord.Embed(
                title="❌ Không tìm thấy ID!",
                description=f"Không tìm thấy dữ liệu Local Storage với ID `{item_id}`.",
                color=discord.Color.red()
            )
            logger.warning(f"Local Storage with ID {item_id} not found for deletion by {interaction.user.display_name} (ID: {interaction.user.id}).")
        await interaction.followup.send(embed=embed, ephemeral=True)
    except sqlite3.Error as e:
        logger.error(f"SQLite Error deleting UG Phone data via /delete_ug_by_id for {interaction.user.display_name}: {e}")
        embed = discord.Embed(
            title="❌ Lỗi xóa!",
            description=f'Đã xảy ra lỗi khi xóa dữ liệu Local Storage: {e}\n'
                        f'Vui lòng kiểm tra console bot để biết chi tiết hoặc liên hệ quản trị viên.',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        logger.critical(f"Unexpected error in /delete_ug_by_id for {interaction.user.display_name}: {e}")
        embed = discord.Embed(
            title="❌ Lỗi không mong muốn!",
            description=f'Đã xảy ra lỗi không mong muốn: {e}',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)

@bot.tree.command(name='balance', description='Check your Hcoin balance.')
async def balance(interaction: discord.Interaction):
    user_id = interaction.user.id
    current_balance = await bot.loop.run_in_executor(None, get_user_hcoin, user_id)
    embed = discord.Embed(
        title="💰 Số dư Hcoin của bạn",
        description=f'Bạn hiện có **{current_balance} coin**.',
        color=discord.Color.gold()
    )
    embed.set_footer(text="Sử dụng coin để nhận Local Storage!")
    await interaction.response.send_message(embed=embed, ephemeral=True)
    logger.info(f"User {interaction.user.display_name} (ID: {user_id}) checked balance: {current_balance} coins.")

@bot.tree.command(name='add_hcoin', description='Add Hcoin to a user.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
@app_commands.describe(user='The user to add Hcoin to.', amount='The amount of Hcoin to add.')
async def add_hcoin(interaction: discord.Interaction, user: discord.Member, amount: int):
    if amount <= 0:
        await interaction.response.send_message("Số lượng Hcoin thêm phải lớn hơn 0.", ephemeral=True)
        return
    await bot.loop.run_in_executor(None, update_user_hcoin, user.id, amount)
    new_balance = await bot.loop.run_in_executor(None, get_user_hcoin, user.id)
    embed = discord.Embed(
        title="✅ Đã thêm Hcoin!",
        description=f'Đã thêm **{amount} coin** cho {user.mention}.',
        color=discord.Color.green()
    )
    embed.add_field(name="Số dư mới", value=f"**{new_balance} coin**", inline=True)
    await interaction.response.send_message(embed=embed)
    logger.info(f"Owner {interaction.user.display_name} (ID: {interaction.user.id}) added {amount} coins to {user.display_name} (ID: {user.id}). New balance: {new_balance}.")

@bot.tree.command(name='remove_hcoin', description='Remove Hcoin from a user.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
@app_commands.describe(user='The user to remove Hcoin from.', amount='The amount of Hcoin to remove.')
async def remove_hcoin(interaction: discord.Interaction, user: discord.Member, amount: int):
    if amount <= 0:
        await interaction.response.send_message("Số lượng Hcoin cần xóa phải lớn hơn 0.", ephemeral=True)
        return
    current_balance = await bot.loop.run_in_executor(None, get_user_hcoin, user.id)
    if current_balance < amount:
        embed = discord.Embed(
            title="⚠️ Không đủ Hcoin để xóa!",
            description=f'{user.mention} chỉ có **{current_balance} coin**. Không thể xóa **{amount} coin**.',
            color=discord.Color.orange()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
        logger.warning(f"Owner {interaction.user.display_name} (ID: {interaction.user.id}) tried to remove {amount} coins from {user.display_name} (ID: {user.id}), but user only has {current_balance}.")
        return
    await bot.loop.run_in_executor(None, update_user_hcoin, user.id, -amount)
    new_balance = await bot.loop.run_in_executor(None, get_user_hcoin, user.id)
    embed = discord.Embed(
        title="✅ Đã xóa Hcoin!",
        description=f'Đã xóa **{amount} coin** từ {user.mention}.',
        color=discord.Color.green()
    )
    embed.add_field(name="Số dư mới", value=f"**{new_balance} coin**", inline=True)
    await interaction.response.send_message(embed=embed)
    logger.info(f"Owner {interaction.user.display_name} (ID: {interaction.user.id}) removed {amount} coins from {user.display_name} (ID: {user.id}). New balance: {new_balance}.")

@bot.tree.command(name='hcoin_top', description='Show top Hcoin balances.')
async def hcoin_top(interaction: discord.Interaction):
    await interaction.response.defer()
    cursor = db.get_cursor()
    cursor.execute("SELECT user_id, hcoin_balance FROM user_balances ORDER BY hcoin_balance DESC LIMIT 10")
    top_users = cursor.fetchall()
    if not top_users:
        embed = discord.Embed(
            title="🏆 Bảng xếp hạng Hcoin",
            description="Chưa có ai trong bảng xếp hạng Hcoin.",
            color=discord.Color.gold()
        )
        await interaction.followup.send(embed=embed)
        return
    description = "**Top 10 người dùng có nhiều Hcoin nhất:**\n\n"
    for i, (user_id, balance) in enumerate(top_users):
        try:
            user = await bot.fetch_user(user_id)
            user_name = user.display_name
        except discord.NotFound:
            user_name = f"Người dùng không tồn tại (ID: {user_id})"
        except Exception:
            user_name = f"Không thể lấy tên (ID: {user_id})"
        description += f"**{i+1}.** {user_name}: **{balance} coin**\n"
    embed = discord.Embed(
        title="🏆 Bảng xếp hạng Hcoin",
        description=description,
        color=discord.Color.gold()
    )
    embed.set_footer(text="Ai sẽ là người đứng đầu?")
    await interaction.followup.send(embed=embed)
    logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) viewed Hcoin top list.")

# Function to split long lines into chunks
def split_long_line(line: str, max_length: int = 1000) -> list:
    if len(line) <= max_length:
        return [line]
    words = line.split()
    chunks = []
    current_chunk = []
    current_length = 0
    for word in words:
        word_length = len(word) + 1  # Account for space
        if current_length + word_length > max_length:
            if current_chunk:
                chunks.append(" ".join(current_chunk))
                current_chunk = [word]
                current_length = word_length
            else:
                # Handle single word longer than max_length
                chunks.append(word[:max_length])
                current_chunk = [word[max_length:]]
                current_length = len(word[max_length:]) + 1
        else:
            current_chunk.append(word)
            current_length += word_length
    if current_chunk:
        chunks.append(" ".join(current_chunk))
    return chunks

@bot.tree.command(name='sing', description='Display the lyrics of the song "Trình" by HIEUTHUHAI, line by line with a 2.5-second delay.')
async def sing(interaction: discord.Interaction):
    await interaction.response.defer()
    lyrics = """
Haizz, fuck it
(Hey, Kewtiie) ey, yah, yah
Ối dồi ôi, ối dồi ôi
Trình là gì mà là trình ai chấm? (Úi dồi)
Anh chỉ biết làm ba mẹ tự hào
Xây căn nhà thật to, ở một mình hai tấm (úi dồi)
Ối dồi ôi, ối dồi ôi
Cứ lên mạng phán xét, tưởng là mình oai lắm
Nhìn vào sự nghiệp anh thèm chảy nước miếng
Giống mấy thằng biến thái nó đang rình ai tắm (đúng không?)
Mua bao nhiêu căn nhà (đếm được, đếm được)
Năm bao nhiêu show (đếm được, đếm được)
Bao nhiêu bài hit (đếm được, đếm được)
Bao nhiêu trong bank (đếm được, đếm được)
Mua bao nhiêu căn nhà (đếm được, đếm được)
Năm bao nhiêu show (đếm được, đếm được)
Bao nhiêu là cup (đếm được, đếm được)
Có bao nhiêu fan (không đếm được, không đếm được, whoo)
Lần đầu tiên mà nhạc anh được hit
Tụi nó nói là do anh may mắn (okay)
Rồi anh hit thêm lần thứ hai
Thằng này không đẹp trai thì cút
Khi anh hit thêm một lần nữa
Có ai thấy nó ngang ngang, ý kiến riêng không hay lắm
Hit lần bốn rồi lại hit tới lần năm
Á-á-á-á, con chó này được push (push)
Rapper không trình, đẹp trai cũng đã quen rồi
Rapper làm hề, gameshow cũng đã quen rồi
Nhạc anh khi xưa OG cũng đã khen rồi
Top trending, ừ thì đâu có giá trị cho tới khi có cái tên mày trong đó
Khoe hoài mà tưởng là top năm luôn không đó
Bốn năm trước đâu ai tin anh sẽ tìm được chỗ đứng
Bốn năm sau anh lại làm nó khó chịu với cái chỗ mà anh đang ngồi
Hay anh phải ngưng làm nhạc tình, chuyển qua làm nhạc mai thúy, bật cho mấy thằng nhõi nghiến
Làm cap rap, nói về cuộc sống giang hồ, số tiền mà anh nhận được sau khi buôn về mỗi chuyến (right)
Nhạc viral mà nó nói không kĩ năng, mấy thằng ngu ngốc ơi, làm ơn đi ra khỏi giếng
Nếu mà nói idol của mày không cần viral, vậy đi thi làm gì nếu không vì sự nổi tiếng?
Yah, miệng mở ra nói toàn là điêu, anh cứ tưởng nó là chiến thần chốt sale (chốt sale)
Anh làm nhạc có nội dung và sâu sắc, đứng ở trên sân khấu mà khán giả họ khóc theo (khóc theo)
Nói lyric của anh viết vô nghĩa hay cái não lâu ngày không xài nó mốc meo? (Bị ngơ à?)
Bình luận thật sự có đầu óc, nhưng mà óc này là óc heo!
Ối dồi ôi, ối dồi ôi
Trình là gì mà là trình ai chấm? (Úi dồi)
Anh chỉ biết làm ba mẹ tự hào
Xây căn nhà thật to, ở một mình hai tấm (úi dồi)
Ối dồi ôi, ối dồi ôi
Cứ lên mạng phán xét, tưởng là mình oai lắm
Nhìn vào sự nghiệp anh thèm chảy nước miếng
Giống mấy thằng biến thái nó đang rình ai tắm
Mua bao nhiêu căn nhà (đếm được, đếm được)
Năm bao nhiêu show (đếm được, đếm được)
Bao nhiêu bài hit (đếm được, đếm được)
Bao nhiêu trong bank (đếm được, đếm được)
Mua bao nhiêu căn nhà (đếm được, đếm được)
Năm bao nhiêu show (đếm được, đếm được)
Bao nhiêu là cup (đếm được, đếm được)
Có bao nhiêu fan (không đếm được, không đếm được)
Mua bao nhiêu căn nhà
Năm bao nhiêu show
Bao nhiêu bài hit
Bao nhiêu trong bank
Mua bao nhiêu căn nhà
Năm bao nhiêu show
Bao nhiêu là cup
Ey, ey
Anh thì không thích những thằng nghe nhạc thượng đẳng
Chỉ đem âm nhạc của tụi anh ra khai thác
Giấu đằng sau lưng là menu lời khen
Cho ai trả tiền hoặc là người nó bias
Có mỗi một câu đó là overrated
Miếng mồi quá ngon nên tụi nó phải nhai nát
Lên quá nhiều bài chỉ để nói về anh thôi
Vậy tại sao là anh đây mà không phải là ai khác?
Vì anh hút view, hot qua từng ngày
365 giống như anh là Isaac
Coi như đánh đổi
Hôm qua bước ra khỏi ngân hàng chắc tầm đâu 15T trong my bag
Xin phép thoát vai showbiz một hôm
Phải quay trở lại với hip-hop vào vai ác
Xin phép thoát vai showbiz một hôm
Phải quay trở lại với hip-hop vào vai ác
Đi tới mọi nơi như là fan BIGBANG
Người ta gọi anh là V.I.P
Re-up nhạc anh được 100 củ khoai
Nhạc nó tự up được một ký khoai mì
Flow của anh đi để lại băng giá thôi
Cold and colder như là dân IT
Trong khi tụi nó vẫn còn đang nói nhiều quá
I just do it, kiếm nhiều check như Nike, aight
Muốn so gì? Học vấn hay là ai đang nhiều bằng?
Pen hơn nhiều thằng, flow hơn nhiều thằng
Để mà so về nhạc hot thì cũng hơn nhiều thằng
Nếu mà muốn nói là hip-hop phải kiêu căng, là ngông nghênh, là ngổ ngáo, vậy thì anh không liều bằng
Còn nếu hip-hop là lối sống, là văn hóa thì nó lại dễ ăn quá, đưa anh em anh đi xa, anh cũng đã hơn hơi nhiều thằng (bam)
Sold out mọi show anh lạng qua
Nghe đâu là đang năm hạn ha?
Cái tên của anh lớn quá nhanh, bất lợi của nó là phải ca rạn da
Nếu mà tụi mày đang muốn hạ anh xuống
Chắc phải đem thêm vài bao đạn K
Không cần xếp hạng anh hạng mấy bởi vì anh là một sao hạng
Sao hạng, sao hạng, sao hạng
Sao, sao?
Sao hạng, sao hạng, sao hạng
Sao, sao?
Sao hạng, sao hạng, sao hạng
Sao, sao, sao, sao, sao, sao, sao, sao, sao, sao
Yah, yah, anh đâu tới đây hạ bệ ai, em nghe ở đâu ra vậy? (Đâu, đâu?)
Anh chỉ muốn đi con đường mới, jealousy in the air 'cause I'm on my way (on my way)
Nếu trình cao là không ai biết tên, sân khấu lớn chưa bao giờ được thấy
Việc giỏi nhất cũng không thể kiếm ra tiền, thì thôi anh, anh là thằng overrated (hah)
Talk to me nice or don't talk at all
The fuck, fuck you wanna say (fuck, fuck, fuck, fuck)
(What the fuck?)
Những người đang thắc mắc sao anh lên nhanh quá đều là những người không đua
Nhìn đường anh đi là một thảm cỏ xanh, họ đâu thấy những ngày trong mưa
Và sẽ còn cao hơn thế nữa, nên đừng hỏi là bây giờ xong chưa
Không phải tiếng của xe bán kem, đó là tiếng dây chuyền anh đong đưa (damn)
"""
    # Split lyrics into individual lines and filter out empty lines
    lyric_lines = [line.strip() for line in lyrics.split('\n') if line.strip()]
    logger.info(f"User {interaction.user.display_name} (ID: {interaction.user.id}) used /sing to display {len(lyric_lines)} lines of Trình by HIEUTHUHAI with 2.5s delay per line/chunk.")
    
    # Send an initial message to confirm the command is running
    await interaction.followup.send(embed=discord.Embed(
        title="🎵 Bắt đầu hát Trình - HIEUTHUHAI 🎵",
        description="Lời bài hát sẽ được gửi từng dòng, mỗi dòng cách nhau 2.5 giây. Các dòng dài sẽ được chia nhỏ để dễ đọc. Hãy chuẩn bị hát theo nào!",
        color=discord.Color.purple()
    ))
    
    # Process each line, splitting if necessary
    total_messages = 0
    max_messages = 100  # Safety limit to prevent excessive messages
    for line_idx, line in enumerate(lyric_lines):
        # Split long lines into chunks
        chunks = split_long_line(line, max_length=1000)
        for chunk_idx, chunk in enumerate(chunks):
            if total_messages >= max_messages:
                await interaction.followup.send(embed=discord.Embed(
                    title="⚠️ Đã đạt giới hạn tin nhắn!",
                    description="Đã gửi quá nhiều tin nhắn. Quá trình gửi lời bài hát đã dừng để tránh spam. Vui lòng thử lại sau.",
                    color=discord.Color.orange()
                ))
                logger.warning(f"Stopped /sing for user {interaction.user.id} at {total_messages} messages due to safety limit.")
                return
            try:
                embed = discord.Embed(
                    title="🎵 Trình - HIEUTHUHAI 🎵" if line_idx == 0 and chunk_idx == 0 else "🎵 Trình - HIEUTHUHAI (Tiếp tục) 🎵",
                    description=f"```\n{chunk}\n```",
                    color=discord.Color.purple()
                )
                if len(chunks) > 1:
                    embed.add_field(name="Phần", value=f"{chunk_idx + 1}/{len(chunks)} của dòng {line_idx + 1}", inline=True)
                if line_idx == 0 and chunk_idx == 0:
                    embed.set_footer(text="Bot By NMTKIET")
                    embed.timestamp = discord.utils.utcnow()
                await interaction.followup.send(embed=embed)
                total_messages += 1
                logger.debug(f"Sent lyric line {line_idx + 1}/{len(lyric_lines)}, part {chunk_idx + 1}/{len(chunks)} for user {interaction.user.id}: {chunk[:50]}...")
                await asyncio.sleep(2.5)  # Delay 2.5 seconds between messages
            except discord.HTTPException as e:
                logger.error(f"Failed to send lyric line {line_idx + 1}/{len(lyric_lines)}, part {chunk_idx + 1}/{len(chunks)} for user {interaction.user.id}: {e}")
                await interaction.followup.send(embed=discord.Embed(
                    title="❌ Lỗi gửi lời bài hát!",
                    description=f"Đã xảy ra lỗi khi gửi dòng {line_idx + 1} (phần {chunk_idx + 1}/{len(chunks)}): `{e}`. Quá trình gửi lời bài hát đã dừng. Vui lòng thử lại sau.",
                    color=discord.Color.red()
                ))
                return

@bot.tree.command(name='info', description='Get information about the bot.')
async def info(interaction: discord.Interaction):
    embed = discord.Embed(
        title="ℹ️ Thông tin Bot",
        description="Chào mừng bạn đến với bot của NMTKIET!",
        color=discord.Color.purple()
    )
    embed.add_field(name="Chức năng chính", value="""
    - `/getcredit`: Nhận mã đổi thưởng để lấy coin.
    - `/redeem`: Đổi mã để nhận coin.
    - `/getugphone`: Sử dụng coin để nhận Local Storage.
    - `/balance`: Kiểm tra số dư coin của bạn.
    - `/hcoin_top`: Xem bảng xếp hạng Hcoin.
    - `/sing`: Hiển thị lời bài hát "Trình" của HIEUTHUHAI, từng dòng cách nhau 2.5 giây (dòng dài được chia nhỏ).
    """, inline=False)
    embed.add_field(name="Các lệnh dành cho chủ sở hữu bot", value="""
    - `/addugphone`: Thêm Local Storage thủ công.
    - `/quickaddug`: Thêm nhiều Local Storage trong một phiên.
    - `/delete_ug_data`: Xóa Local Storage cụ thể (bằng nội dung).
    - `/delete_ug_by_id`: Xóa Local Storage cụ thể (bằng ID).
    - `/remove`: Xóa mã đổi thưởng.
    - `/list`: Liệt kê mã, link Pastebin hoặc Local Storage.
    - `/add_hcoin`: Thêm coin cho người dùng.
    - `/remove_hcoin`: Xóa coin khỏi người dùng.
    - `/sync_commands`: Đồng bộ lệnh slash.
    - `/deduplicate_ugphone`: Chạy deduplication thủ công.
    """, inline=False)
    embed.set_footer(text="Bot By SNIPAVN|Code Bot By NMTKIET")
    embed.timestamp = discord.utils.utcnow()
    await interaction.response.send_message(embed=embed, ephemeral=False)

@bot.tree.command(name='deduplicate_ugphone', description='Manually remove duplicate Local Storage entries.')
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
async def deduplicate_ug_phone_command(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    logger.info(f"Owner {interaction.user.display_name} (ID: {interaction.user.id}) used /deduplicate_ugphone.")
    try:
        initial_count, final_count = await bot.loop.run_in_executor(None, deduplicate_ug_phones_data)
        removed_count = initial_count - final_count
        if removed_count > 0:
            embed = discord.Embed(
                title="✅ Trùng lặp đã xử lý!",
                description=f"Đã tìm thấy và loại bỏ **{removed_count}** mục Local Storage trùng lặp.\n"
                            f"Tổng số mục ban đầu: **{initial_count}**\n"
                            f"Tổng số mục sau khi deduplicate: **{final_count}**",
                color=discord.Color.green()
            )
            logger.info(f"Deduplication successful for ug_phones. Removed {removed_count} duplicates.")
        else:
            embed = discord.Embed(
                title="ℹ️ Không có trùng lặp!",
                description="Không tìm thấy mục Local Storage trùng lặp nào trong kho.",
                color=discord.Color.blue()
            )
            logger.info("No duplicates found in ug_phones table.")
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        logger.critical(f"Error during deduplication via /deduplicate_ugphone for {interaction.user.display_name}: {e}")
        embed = discord.Embed(
            title="❌ Lỗi khi deduplicate!",
            description=f'Đã xảy ra lỗi khi xử lý trùng lặp: {e}',
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)

@bot.tree.command(name="sync_commands", description="Syncs slash commands to Discord.")
@app_commands.check(is_owner)
@app_commands.check(is_allowed_admin_channel)
async def sync_commands(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    logger.info(f"Owner {interaction.user.display_name} (ID: {interaction.user.id}) used /sync_commands.")
    try:
        if TEST_GUILD_ID:
            test_guild_id_int = int(TEST_GUILD_ID)
            test_guild = discord.Object(id=test_guild_id_int)
            bot.tree.copy_global_to(guild=test_guild)
            await bot.tree.sync(guild=test_guild)
            embed = discord.Embed(
                title="✅ Đồng bộ lệnh thành công!",
                description=f"Đã đồng bộ lệnh Slash cho guild test `{test_guild_id_int}`.",
                color=discord.Color.green()
            )
            logger.info(f"Slash commands synced to TEST_GUILD_ID: {test_guild_id_int}.")
        else:
            await bot.tree.sync()
            embed = discord.Embed(
                title="✅ Đồng bộ lệnh thành công!",
                description="Đã đồng bộ lệnh Slash toàn cầu. Các lệnh có thể mất tới 1 giờ để xuất hiện.",
                color=discord.Color.green()
            )
            logger.info("Slash commands synced globally.")
        await interaction.followup.send(embed=embed, ephemeral=True)
    except Exception as e:
        logger.error(f"Error syncing commands for {interaction.user.display_name}: {e}")
        embed = discord.Embed(
            title="❌ Lỗi đồng bộ lệnh!",
            description=f"Đã xảy ra lỗi khi đồng bộ lệnh: `{e}`",
            color=discord.Color.red()
        )
        await interaction.followup.send(embed=embed, ephemeral=True)

if __name__ == "__main__":
    if DISCORD_BOT_TOKEN:
        try:
            bot.run(DISCORD_BOT_TOKEN)
        except Exception as e:
            logger.critical(f"Failed to run bot: {e}")
            print(f"Error: Failed to run bot. Please check your DISCORD_BOT_TOKEN in the .env file. Error: {e}")
    else:
        logger.critical("DISCORD_BOT_TOKEN not found in .env file.")
        print("Error: DISCORD_BOT_TOKEN not found in .env file. Please set it.")
